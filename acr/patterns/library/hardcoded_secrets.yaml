id: hardcoded-secrets
name: Hardcoded Secrets
category: cryptography
severity: critical
cwe: CWE-798
owasp: A07:2021-Identification and Authentication Failures

description: |
  Hardcoded secrets (API keys, passwords, tokens, certificates) are embedded directly in source code,
  making them vulnerable to exposure through version control, code review, or compiled binaries.

references:
  - https://cwe.mitre.org/data/definitions/798.html
  - https://owasp.org/www-project-application-security-verification-standard/

affected_languages:
  - python
  - javascript
  - typescript
  - java
  - go
  - ruby
  - php

affected_frameworks:
  - all

secret_types:
  - AWS Access Keys (AKIA[0-9A-Z]{16})
  - AWS Secret Keys ([a-zA-Z0-9/+]{40})
  - API Keys (sk-.*, api_key.*, x-api-key, xapikey)
  - JWT Tokens (eyJ[0-9a-zA-Z_-]*\.[0-9a-zA-Z_-]*\.[0-9a-zA-Z_-]*)
  - Passwords (password.*, pass.*, secret.*, pwd.*)
  - Private Keys (-----BEGIN.*PRIVATE KEY-----)
  - Certificates (-----BEGIN CERTIFICATE-----)
  - Database Connection Strings (mysql://, postgres://, mongodb://, sqlite://)
  - OAuth Tokens (Bearer [0-9a-zA-Z-._~+/]+=*)
  - SSH Private Keys (-----BEGIN.*PRIVATE KEY-----, ssh-rsa)

detection:
  static:
    - pattern: "(AKIA[0-9A-Z]{16})"
      description: AWS Access Key ID
      confidence: high

    - pattern: "(sk-[a-zA-Z0-9]{20,})"
      description: Stripe API key
      confidence: high

    - pattern: "(x-api-key\\s*[:=]\\s*['\"][a-zA-Z0-9_-]{10,}['\"])"
      description: Generic API key header
      confidence: high

    - pattern: "(password\\s*[:=]\\s*['\"][^'\"]{6,}['\"])"
      description: Hardcoded password string
      confidence: high

    - pattern: "(secret\\s*[:=]\\s*['\"][^'\"]{10,}['\"])"
      description: Hardcoded secret string
      confidence: high

    - pattern: "(-----BEGIN (RSA |EC )?PRIVATE KEY-----)"
      description: Private key in PEM format
      confidence: high

    - pattern: "(-----BEGIN CERTIFICATE-----)"
      description: Certificate in PEM format
      confidence: high

    - pattern: "(mysql://[^\"'\\s]+:[^\"'\\s]+@)"
      description: MySQL connection string with credentials
      confidence: high

    - pattern: "(postgres://[^\"'\\s]+:[^\"'\\s]+@)"
      description: PostgreSQL connection string with credentials
      confidence: high

    - pattern: "(mongodb://[^\"'\\s]+:[^\"'\\s]+@)"
      description: MongoDB connection string with credentials
      confidence: high

    - pattern: "(Bearer [a-zA-Z0-9_.-]{20,})"
      description: Bearer token
      confidence: high

    - pattern: "(api_?key\\s*=\\s*['\"][a-zA-Z0-9_-]{20,}['\"])"
      description: API key assignment
      confidence: high

remediation:
  description: Use environment variables or secret management systems

  code_before: |
    # Hardcoded secret in code
    AWS_ACCESS_KEY = "AKIAIOSFODNN7EXAMPLE"
    AWS_SECRET_KEY = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
    API_KEY = "sk_test_4eC39HqLyjWDarjtT1zdp7dc"

  code_after: |
    # Use environment variables
    import os
    from dotenv import load_dotenv

    load_dotenv()

    AWS_ACCESS_KEY = os.getenv('AWS_ACCESS_KEY_ID')
    AWS_SECRET_KEY = os.getenv('AWS_SECRET_ACCESS_KEY')
    API_KEY = os.getenv('STRIPE_API_KEY')

  code_after_config: |
    # Use configuration management
    from config import settings

    AWS_ACCESS_KEY = settings.aws_access_key
    AWS_SECRET_KEY = settings.aws_secret_key
    API_KEY = settings.stripe_api_key

  code_after_secret_manager: |
    # Use AWS Secrets Manager
    import boto3
    import json

    client = boto3.client('secretsmanager')
    response = client.get_secret_value(SecretId='my-app/credentials')
    secrets = json.loads(response['SecretString'])

    AWS_ACCESS_KEY = secrets['aws_access_key']
    AWS_SECRET_KEY = secrets['aws_secret_key']

examples:
  vulnerable:
    - |
      # database.py
      DATABASE_URL = "postgresql://admin:supersecretpassword123@db.example.com/myapp"

    - |
      # aws_config.py
      s3_client = boto3.client(
          's3',
          aws_access_key_id='AKIAIOSFODNN7EXAMPLE',
          aws_secret_access_key='wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY'
      )

    - |
      # stripe.py
      stripe.api_key = "sk_test_4eC39HqLyjWDarjtT1zdp7dc"

    - |
      # api.py
      headers = {
          'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'
      }

    - |
      # keys.py
      PRIVATE_KEY = """
      -----BEGIN RSA PRIVATE KEY-----
      MIIEpAIBAAKCAQEAz7T4Gk5F8X9p...
      -----END RSA PRIVATE KEY-----
      """

  secure:
    - |
      # database.py
      import os

      DATABASE_URL = os.getenv('DATABASE_URL')
      if not DATABASE_URL:
          raise ValueError("DATABASE_URL environment variable not set")

    - |
      # aws_config.py
      import boto3

      # Use AWS credentials from environment or ~/.aws/credentials
      s3_client = boto3.client('s3')

    - |
      # stripe.py
      import os

      stripe.api_key = os.getenv('STRIPE_API_KEY')

    - |
      # api.py
      import os

      token = os.getenv('API_TOKEN')
      headers = {
          'Authorization': f'Bearer {token}'
      }

security_recommendations:
  - Use environment variables for secrets
  - Store secrets in secure secret managers (AWS Secrets Manager, HashiCorp Vault)
  - Use .env files with proper .gitignore
  - Never commit secrets to version control
  - Use secret scanning tools on CI/CD (e.g., git-secrets, truffleHog)
  - Rotate secrets immediately if accidentally committed
  - Use least privilege for API keys and service accounts

llm_prompts:
  analyze: |
    Analyze this code for hardcoded secrets and credentials. Look for:
    1. API keys (AWS, Stripe, Google, etc.)
    2. Database credentials
    3. Authentication tokens and passwords
    4. Private keys and certificates
    5. Any suspicious hardcoded strings that look like secrets

    For each finding:
    - Identify the type of secret
    - Provide the exact vulnerable line
    - Explain the security risk
    - Recommend proper secret management approach

  generate_attack: |
    Explain the security implications of this hardcoded secret. Describe:
    1. How an attacker could discover this secret
    2. What damage could be done with the secret
    3. How the secret could be extracted from:
       - Public repositories
       - Compiled binaries
       - Code review systems
    4. Steps to remediate and rotate the secret
