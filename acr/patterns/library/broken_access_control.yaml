id: broken_access_control
name: Broken Access Control
category: access_control
severity: critical
cwe: CWE-284
owasp: A01:2021-Broken Access Control

description: |
  Broken Access Control is the #1 vulnerability on OWASP Top 10 2021. It occurs when
  users can act outside of their intended permissions, allowing unauthorized access to
  resources, data, or functionality. This includes IDOR, missing authorization checks,
  privilege escalation, and exposed administrative interfaces.

references:
- https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control
- https://cwe.mitre.org/data/definitions/284.html
- https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html

affected_languages:
- python
- javascript
- typescript

affected_frameworks:
- flask
- django
- fastapi
- express
- nestjs

vulnerability_types:
- idor: Insecure Direct Object Reference - accessing resources by guessing IDs
- missing_auth: Missing authentication on sensitive endpoints
- privilege_escalation: Privilege escalation by modifying roles/permissions
- admin_exposure: Exposed administrative interfaces without proper protection
- cors_misconfig: CORS misconfiguration allowing unauthorized cross-origin access
- force_browsing: Force browsing to access hidden/protected endpoints
- parameter_tampering: Parameter tampering to bypass authorization checks

detection:
  static:
  - pattern: '@app\.route\(.*<int:id>.*\)'
    description: URL parameter without authorization check
    confidence: low

  - pattern: def (get|update|delete|edit)\(.*user_id\)
    description: Function operating on user_id without authorization check
    confidence: medium

  - pattern: (User|Account|Profile|Order|Invoice)\.objects\.get\(id=.*request\.
    description: Direct object access from user input without authorization (Django)
    confidence: high

  - pattern: db\.query\(.*WHERE id =.*request\.
    description: Direct object lookup from user input (SQLAlchemy)
    confidence: high

  - pattern: '@(login_required|authenticated)\s*\n\s*def (admin|dashboard|settings|config|users_delete)'
    description: Admin endpoint only checking auth, not admin role
    confidence: high

  - pattern: app\.get\(\['/api/users/.*'\],\s*\(req, res\)\s*=>
    description: Express endpoint without middleware/authorization check
    confidence: medium

  - pattern: res\.send\(User\.findById\(req\.params\.id\)\)
    description: Direct object access in Express without authorization
    confidence: high

  - pattern: GET|POST|PUT|DELETE.*admin|users|settings
    description: Administrative endpoint route definition
    confidence: low

  - pattern: cors\(\{\s*origin:\s*['"]\*['"].*\}\)
    description: CORS allowing all origins (security risk)
    confidence: medium

  - pattern: '@(jwt_required|auth_required)\s*\n.*@admin_required'
    description: Missing admin decorator on function returning sensitive data
    confidence: high

  - pattern: session\['role'\]\s*=\s*(request\.\w+|\w+)
    description: Modifying session role based on user input (privilege escalation)
    confidence: high

  - pattern: (allow|can|has_permission|check_access)\(.*request\.(user|session|args|form|json|params)\)
    description: Authorization check using untrusted input
    confidence: high

  - pattern: if\s+\(user\.role\s*==\s*['"]admin['"]\)
    description: Hardcoded role check that could be bypassed
    confidence: medium

  data_flow:
  - source: (request\.(args|form|json|params|view_args|headers|cookies)|req\.(params|query|body|headers))
    sink: (User|Account|Profile|Order|Invoice|Document)\.(objects\.get|findById|findOne|query|find)
    sanitizers: (check_owner|verify_access|has_permission|can_access|is_owner)

  - source: (request\.(args|form|json|params|view_args|headers|cookies)|req\.(params|query|body|headers))
    sink: (delete|update|edit|destroy|remove)\(
    sanitizers: (check_owner|verify_access|has_permission|can_access|is_owner|is_admin)

remediation:
  description: Implement proper authorization checks at every endpoint that accesses or modifies resources. Always verify the requesting user has permission to perform the action on the specific resource.

  code_before: |
    from flask import Flask, request

    app = Flask(__name__)

    # VULNERABLE: No authorization check
    @app.route('/api/users/<int:user_id>')
    def get_user(user_id):
        user = User.objects.get(id=user_id)
        return jsonify(user.to_dict())

    # VULNERABLE: Only checks auth, not admin role
    @app.route('/admin/delete_user/<int:user_id>')
    @login_required
    def delete_user(user_id):
        user = User.objects.get(id=user_id)
        user.delete()
        return jsonify({'status': 'deleted'})

  code_after: |
    from flask import Flask, request, jsonify
    from flask_login import login_required, current_user

    app = Flask(__name__)

    # SECURE: Verify ownership of resource
    @app.route('/api/users/<int:user_id>')
    @login_required
    def get_user(user_id):
        if current_user.id != user_id and not current_user.is_admin:
            return jsonify({'error': 'Forbidden'}), 403

        user = User.objects.get(id=user_id)
        return jsonify(user.to_dict())

    # SECURE: Check both auth and admin role
    @app.route('/admin/delete_user/<int:user_id>')
    @login_required
    def delete_user(user_id):
        if not current_user.is_admin:
            return jsonify({'error': 'Unauthorized'}), 401

        user = User.objects.get(id=user_id)
        user.delete()
        return jsonify({'status': 'deleted'})

  code_before_django: |
    # VULNERABLE: IDOR - anyone can access any order
    @api_view(['GET'])
    def get_order(request, order_id):
        order = Order.objects.get(id=order_id)
        return Response(OrderSerializer(order).data)

  code_after_django: |
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.decorators import api_view, permission_classes

    # SECURE: Verify user owns the order or is admin
    @api_view(['GET'])
    @permission_classes([IsAuthenticated])
    def get_order(request, order_id):
        order = get_object_or_404(Order, id=order_id)

        if order.user_id != request.user.id and not request.user.is_staff:
            return Response({'error': 'Forbidden'}, status=403)

        return Response(OrderSerializer(order).data)

  code_before_express: |
    // VULNERABLE: No authorization check
    app.get('/api/orders/:orderId', (req, res) => {
      const order = await Order.findById(req.params.orderId);
      res.json(order);
    });

    // VULNERABLE: CORS allows any origin
    app.use(cors({ origin: '*' }));

  code_after_express: |
    // SECURE: Verify ownership
    app.get('/api/orders/:orderId', authenticate, async (req, res) => {
      const order = await Order.findById(req.params.orderId);

      if (order.userId !== req.user.id && !req.user.isAdmin) {
        return res.status(403).json({ error: 'Forbidden' });
      }

      res.json(order);
    });

    // SECURE: Restrict CORS to specific origins
    app.use(cors({
      origin: ['https://yourdomain.com'],
      credentials: true
    }));

  code_before_nestjs: |
    // VULNERABLE: No authorization guard
    @Get('users/:id')
    async getUser(@Param('id') id: string) {
      return await this.userService.findOne(id);
    }

  code_after_nestjs: |
    // SECURE: Use authorization guard and check ownership
    @Get('users/:id')
    @UseGuards(JwtAuthGuard)
    async getUser(@Param('id') id: string, @Request() req) {
      const user = await this.userService.findOne(id);

      if (user.id !== req.user.id && !req.user.isAdmin) {
        throw new ForbiddenException('You do not have permission');
      }

      return user;
    }

examples:
  vulnerable:
  - |
    # IDOR - accessing other users' data
    @app.route('/profile/<int:user_id>')
    @login_required
    def view_profile(user_id):
        profile = Profile.objects.get(id=user_id)
        return render_template('profile.html', profile=profile)

  - |
    # Privilege escalation via session manipulation
    @app.route('/set_role', methods=['POST'])
    def set_role():
        new_role = request.form.get('role')
        session['role'] = new_role  # VULNERABLE: Setting role from user input
        return jsonify({'status': 'role updated'})

  - |
    # Missing authorization on delete endpoint
    @app.route('/api/documents/<int:doc_id>', methods=['DELETE'])
    def delete_document(doc_id):
        doc = Document.objects.get(id=doc_id)
        doc.delete()
        return jsonify({'status': 'deleted'})

  - |
    # Express - IDOR vulnerability
    app.get('/api/account/:accountId', async (req, res) => {
      const account = await Account.findById(req.params.accountId);
      res.json(account);  // Anyone can view any account
    });

  - |
    // Exposed admin endpoint without protection
    app.delete('/admin/users/:userId', async (req, res) => {
      await User.findByIdAndDelete(req.params.userId);
      res.json({ success: true });
    });

  - |
    # Django - Missing ownership check
    def update_order(request, order_id):
        order = Order.objects.get(id=order_id)
        order.status = request.POST.get('status')
        order.save()
        return JsonResponse(order.to_dict())

  - |
    # CORS misconfiguration
    from flask_cors import CORS
    CORS(app, origins='*')  # Allows any origin to make requests

  secure:
  - |
    # SECURE: Verify resource ownership
    @app.route('/profile/<int:user_id>')
    @login_required
    def view_profile(user_id):
        if current_user.id != user_id and not current_user.is_admin:
            abort(403)

        profile = Profile.objects.get(id=user_id)
        return render_template('profile.html', profile=profile)

  - |
    # SECURE: Role validation
    @app.route('/set_role', methods=['POST'])
    @admin_required
    def set_role():
        target_user_id = request.form.get('user_id')
        if not is_valid_role_transition(current_user, target_user_id, new_role):
            return jsonify({'error': 'Invalid role change'}), 403

        user = User.objects.get(id=target_user_id)
        user.role = new_role
        user.save()
        return jsonify({'status': 'role updated'})

  - |
    # SECURE: Authorization required
    @app.route('/api/documents/<int:doc_id>', methods=['DELETE'])
    @login_required
    def delete_document(doc_id):
        doc = Document.objects.get(id=doc_id)

        if doc.owner_id != current_user.id and not current_user.is_admin:
            return jsonify({'error': 'Forbidden'}), 403

        doc.delete()
        return jsonify({'status': 'deleted'})

  - |
    // SECURE: Express with ownership check
    app.get('/api/account/:accountId', authenticate, async (req, res) => {
      const account = await Account.findById(req.params.accountId);

      if (account.userId !== req.user.id && !req.user.isAdmin) {
        return res.status(403).json({ error: 'Forbidden' });
      }

      res.json(account);
    });

  - |
    // SECURE: Admin-only endpoint
    app.delete('/admin/users/:userId',
      authenticate,
      requireAdmin,
      async (req, res) => {
        await User.findByIdAndDelete(req.params.userId);
        res.json({ success: true });
      }
    );

  - |
    # SECURE: Django with ownership check
    @api_view(['PUT'])
    @permission_classes([IsAuthenticated])
    def update_order(request, order_id):
        order = get_object_or_404(Order, id=order_id)

        if order.user_id != request.user.id and not request.user.is_staff:
            return Response({'error': 'Forbidden'}, status=403)

        order.status = request.data.get('status', order.status)
        order.save()
        return JsonResponse(OrderSerializer(order).data)

  - |
    # SECURE: Restricted CORS
    from flask_cors import CORS
    CORS(app, origins=['https://yourdomain.com'], supports_credentials=True)

attack_vectors:
- vector: IDOR - Insecure Direct Object Reference
  payload: GET /api/orders/123 (changing 123 to 456 to access another user's order)
  description: Access or modify resources by guessing or enumerating IDs (order_id, user_id, document_id) without authorization checks

- vector: Privilege Escalation via Parameter Tampering
  payload: "POST /update_profile { 'role': 'admin' }"
  description: Modify request parameters to escalate privileges by setting role, is_admin, or permission fields

- vector: Force Browsing to Admin Interfaces
  payload: GET /admin, GET /api/admin/users, GET /dashboard/admin
  description: Access administrative interfaces by guessing or enumerating URLs

- vector: Session Manipulation
  payload: Modifying session['role'] or session['user_id'] cookie values
  description: Tamper with session data to gain unauthorized access or elevate privileges

- vector: CORS-Based Attack
  payload: Cross-origin request from malicious.com to API with origin='*'
  description: Exploit permissive CORS configuration to make unauthorized requests on behalf of authenticated users

- vector: Mass Assignment/Parameter Pollution
  payload: "POST /users/update { 'id': 1, 'is_admin': true }"
  description: Submit unexpected parameters to modify object properties that should not be user-modifiable

- vector: Bypassing Missing Authorization
  payload: Direct API call to DELETE /api/documents/123 without proper token/role
  description: Exploit endpoints that only check authentication but not authorization (role/ownership)

- vector: Horizontal Privilege Escalation
  payload: GET /api/users/456/orders (accessing another user's data when you're user 123)
  description: Access data or perform actions for other users at the same privilege level

llm_prompts:
  analyze: |
    Analyze this code for Broken Access Control vulnerabilities (OWASP A01:2021). Focus on:

    1. **IDOR (Insecure Direct Object References)**:
       - Direct object access using IDs from user input
       - No ownership verification (user_id == current_user.id)
       - Accessing other users' resources by guessing IDs

    2. **Missing Authorization Checks**:
       - Endpoints that only check authentication, not authorization
       - Sensitive operations without role/permission verification
       - Admin endpoints accessible to non-admin users

    3. **Privilege Escalation**:
       - Role assignment/modification from user input
       - Session manipulation to change roles
       - Mass assignment allowing role/permission modification

    4. **CORS Misconfiguration**:
       - CORS allowing all origins ('*')
       - CORS allowing arbitrary origins with credentials

    5. **Exposed Administrative Interfaces**:
       - Admin endpoints without proper protection
       - Configuration endpoints accessible to unauthorized users

    For each finding, provide:
    - Type of access control vulnerability
    - Specific vulnerable code location
    - Attack scenario and impact
    - Recommended fix (ownership checks, role verification, CORS restrictions)

  generate_attack: |
    Generate a Broken Access Control attack for this code. The attack should:

    1. Identify the specific access control weakness (IDOR, privilege escalation, missing auth)
    2. Provide concrete attack steps:
       - Enumerate or guess object IDs
       - Modify request parameters to escalate privileges
       - Access hidden/administrative endpoints
       - Bypass authorization checks
    3. Show exact HTTP requests with payloads
    4. Explain the impact (data breach, account takeover, system compromise)
    5. Suggest remediation (ownership verification, role-based access control, CORS restrictions)

    Focus on attacks that allow an attacker to:
    - Access another user's data or account
    - Gain administrative privileges
    - Delete or modify resources they shouldn't
    - Access hidden/protected functionality

  remediation_guidance: |
    For Broken Access Control vulnerabilities found in this code, provide:

    1. **Authorization Best Practices**:
       - Implement defense in depth: check authentication AND authorization
       - Verify resource ownership for all CRUD operations
       - Use role-based access control (RBAC) or attribute-based access control (ABAC)
       - Deny by default, explicitly allow specific actions

    2. **IDOR Prevention**:
       - Always verify the requesting user owns the resource
       - Use indirect references (UUIDs) instead of sequential IDs
       - Implement proper ownership checks at the service layer

    3. **Privilege Escalation Prevention**:
       - Never set roles/permissions from user input
       - Use server-side role assignment with audit logging
       - Implement proper session management (tamper-proof sessions)
       - Validate all object properties before saving (mass assignment protection)

    4. **CORS Security**:
       - Restrict CORS to specific, trusted origins
       - Avoid using origin='*' with credentials
       - Implement CSRF protection for state-changing requests

    5. **Administrative Interface Protection**:
       - Require additional authentication (MFA) for admin access
       - Implement IP allowlisting for admin endpoints
       - Log and alert on administrative actions

    6. **Code Examples**:
       - Show secure authorization check implementations
       - Demonstrate ownership verification patterns
       - Provide secure CORS configuration examples
       - Show proper RBAC implementation
