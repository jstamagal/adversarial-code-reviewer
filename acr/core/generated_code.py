# Copyright 2026 Adversarial Code Reviewer Contributors
#
# Licensed under the MIT License;
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://opensource.org/licenses/MIT
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Generated code detection and exclusion support."""

import re
from pathlib import Path
from typing import List, Optional, Pattern, Set

from acr.utils.logger import get_logger

log = get_logger(__name__)


class GeneratedCodeDetector:
    """Detect and manage generated code files."""

    DEFAULT_PATTERNS = [
        r"# .* code .* generated by",
        r"# .* auto-generated",
        r"# .* automatically generated",
        r"# .*generated",
        r"# .* DO NOT EDIT",
        r"# .* This file was auto-generated",
        r"Generated by Protobuf",
        r"Generated by gRPC",
        r"Generated by OpenAPI Generator",
        r"Generated by Swagger Codegen",
        r"Generated by mypy-protobuf",
        r"Code generated by Protocol Buffers",
        r"@generated",
        r"@codegen",
        r"@auto-generated",
        r"<auto-generated>",
    ]

    DEFAULT_FILE_PATTERNS = [
        r".*_pb2\.py$",
        r".*_pb2_grpc\.py$",
        r".*_pb\.py$",
        r"api_.*\.py$",
        r".*_generated\.py$",
        r".*_pb\.",
        r".*\.pb\.",
        r".*\.grpc\.",
    ]

    DEFAULT_PATH_PATTERNS = [
        r"proto/",
        r"protobuf/",
        r"generated/",
        r"openapi/",
        r"swagger/",
        r"stubs/",
        r"build/generated/",
        r"target/generated-sources/",
        r"node_modules/@types/",
    ]

    def __init__(self, config=None):
        """Initialize generated code detector.

        Args:
            config: ACR configuration object
        """
        self.config = config
        self._compiled_content_patterns: List[Pattern[str]] = []
        self._compiled_file_patterns: List[Pattern[str]] = []
        self._compiled_path_patterns: List[Pattern[str]] = []
        self._custom_patterns: Set[str] = set()
        self._excluded_files: Set[str] = set()
        self._warned_files: Set[str] = set()

        self._compile_patterns()

    def _compile_patterns(self):
        """Compile regex patterns for matching."""
        patterns = self.DEFAULT_PATTERNS.copy()
        if self.config:
            custom_patterns = self._get_custom_patterns()
            patterns.extend(custom_patterns)

        self._compiled_content_patterns = [
            re.compile(pattern, re.IGNORECASE | re.MULTILINE) for pattern in patterns
        ]

        self._compiled_file_patterns = [
            re.compile(pattern) for pattern in self.DEFAULT_FILE_PATTERNS
        ]

        self._compiled_path_patterns = [
            re.compile(pattern) for pattern in self.DEFAULT_PATH_PATTERNS
        ]

    def _get_custom_patterns(self) -> List[str]:
        """Get custom generated code patterns from configuration.

        Returns:
            List of custom regex patterns
        """
        custom_patterns = []

        if self.config:
            if hasattr(self.config, "exclude"):
                exclude_config = self.config.exclude
                if hasattr(exclude_config, "generated_code_patterns"):
                    custom_patterns.extend(exclude_config.generated_code_patterns or [])

        return custom_patterns

    def detect_from_content(self, source_code: str, file_path: Path) -> bool:
        """Detect if code is generated from its content.

        Args:
            source_code: Source code content
            file_path: Path to file

        Returns:
            True if file appears to be generated
        """
        for pattern in self._compiled_content_patterns:
            if pattern.search(source_code):
                if str(file_path) not in self._warned_files:
                    log.debug(f"Detected generated code by content pattern: {file_path}")
                    self._warned_files.add(str(file_path))
                return True

        return False

    def detect_from_filename(self, file_path: Path) -> bool:
        """Detect if file is generated from its filename.

        Args:
            file_path: Path to file

        Returns:
            True if filename matches generated code pattern
        """
        filename = file_path.name

        for pattern in self._compiled_file_patterns:
            if pattern.search(filename):
                if str(file_path) not in self._warned_files:
                    log.debug(f"Detected generated code by filename pattern: {file_path}")
                    self._warned_files.add(str(file_path))
                return True

        return False

    def detect_from_path(self, file_path: Path) -> bool:
        """Detect if file is generated from its directory path.

        Args:
            file_path: Path to file

        Returns:
            True if path matches generated code directory pattern
        """
        path_str = str(file_path)

        for pattern in self._compiled_path_patterns:
            if pattern.search(path_str):
                if str(file_path) not in self._warned_files:
                    log.debug(f"Detected generated code by path pattern: {file_path}")
                    self._warned_files.add(str(file_path))
                return True

        return False

    def is_generated_code(self, file_path: Path, source_code: Optional[str] = None) -> bool:
        """Determine if a file is generated code.

        Args:
            file_path: Path to file
            source_code: Optional source code content for content-based detection

        Returns:
            True if file is generated code
        """
        if source_code is not None:
            if self.detect_from_content(source_code, file_path):
                return True

        if self.detect_from_filename(file_path):
            return True

        if self.detect_from_path(file_path):
            return True

        return False

    def should_analyze(self, file_path: Path, source_code: Optional[str] = None) -> bool:
        """Determine if generated code should be analyzed.

        Args:
            file_path: Path to file
            source_code: Optional source code content

        Returns:
            True if file should be analyzed, False if it should be excluded
        """
        if not self.is_generated_code(file_path, source_code):
            return True

        return self._is_analyze_generated_enabled()

    def _is_analyze_generated_enabled(self) -> bool:
        """Check if analysis of generated code is enabled.

        Returns:
            True if generated code should be analyzed
        """
        if not self.config:
            return False

        if hasattr(self.config, "analysis"):
            analysis_config = self.config.analysis
            if hasattr(analysis_config, "analyze_generated_code"):
                return analysis_config.analyze_generated_code

        return False

    def get_excluded_files(self) -> Set[str]:
        """Get set of excluded generated code files.

        Returns:
            Set of file paths that have been excluded
        """
        return self._excluded_files.copy()

    def add_excluded_file(self, file_path: Path):
        """Add a file to the excluded files list.

        Args:
            file_path: Path to file being excluded
        """
        self._excluded_files.add(str(file_path))
        log.debug(f"Excluded generated code file: {file_path}")

    def add_custom_pattern(self, pattern: str):
        """Add a custom generated code detection pattern.

        Args:
            pattern: Regex pattern string to add
        """
        if pattern in self._custom_patterns:
            return

        try:
            compiled = re.compile(pattern, re.IGNORECASE | re.MULTILINE)
            self._custom_patterns.add(pattern)
            self._compiled_content_patterns.append(compiled)
            log.debug(f"Added custom generated code pattern: {pattern}")
        except re.error as e:
            log.warning(f"Failed to compile custom pattern '{pattern}': {e}")

    def get_detection_methods(
        self, file_path: Path, source_code: Optional[str] = None
    ) -> List[str]:
        """Get list of detection methods that matched for a file.

        Args:
            file_path: Path to file
            source_code: Optional source code content

        Returns:
            List of detection method names that matched
        """
        methods = []

        if source_code is not None and self.detect_from_content(source_code, file_path):
            methods.append("content")

        if self.detect_from_filename(file_path):
            methods.append("filename")

        if self.detect_from_path(file_path):
            methods.append("path")

        return methods

    def reset_warnings(self):
        """Reset the warning tracking for files."""
        self._warned_files.clear()
